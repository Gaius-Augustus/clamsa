import gzip
import re
import random
import numpy as np




# reverse complement function to obtain minus strand sequences
trtbl = "".maketrans("acgt", "tgca")

def reverse_complement(seq):
    return seq[::-1].translate(trtbl)




# take any negative sample only with probability 1 / undersample_neg_by_factor
# set to 1.0 to use all negative examples


def import_augustus_training_file(path, undersample_neg_by_factor = 1., alphabet=['a', 'c', 'g', 't']):
    """ Imports the training files generated by augustus. This method is tied to the specific
     implementation of GeneMSA::getAllOEMsas and GeneMSA::getMsa.
    """
    
    # entries already read
    training_data = []
    
    # counts number of unique species encountered the file
    num_species = 0
    
    # translation between alphabet and indices in the alphabet
    # {'a': 0, 'c': 1, 'g': 2, 't': 3}
    alpha_indices = dict(zip(alphabet, range(len(alphabet))))
    
    
    with gzip.open(path, 'rt') if path.endswith('.gz') else open(path, 'r') as f:
        
        # Regex Pattern recognizing lines generated by GeneMSA::getMsa
        slice_pattern = re.compile("^[0-9]+\\t[0-9]+\\t\\t[acgt\-]+")
        
        # whether the current sequence should be skipped due to 
        # a undersample roll
        skip_entry = False
        
        for line in f:
            
            # parse the lines generated by GeneMSA::getAllOEMsas
            if line[:2] == "y=":
                
                # decide whether the upcoming entry should be skipped
                skip_entry = line[2]=='0' and random.random() > 1. / undersample_neg_by_factor
                
                if skip_entry:
                    continue
                
                oe_data = line.split("\t")
                y = int(oe_data[0][2])
                cid = oe_data[2]
                start_idx = int(oe_data[3])
                end_idx = int(oe_data[4])
                is_on_plus_strand = (oe_data[5] == "+")
                frame = int(oe_data[6][0])
                
                
                training_data.append({
                    "y" : y,
                    "cid" : cid,
                    "start_idx" : start_idx,
                    "end_idx" : end_idx,
                    "is_on_plus_strand" : is_on_plus_strand,
                    "frame" : frame,
                    "spec_ids" : [],
                    "offsets" : [],
                    "seq" : [], # a, c, g, t, n, -
                    "S" : [],   # 0, 1, 2, 3
                })
            
            # parse the lines generated by GeneMSA::getMsa
            elif slice_pattern.match(line) and not skip_entry:
                slice_data = line.split("\t")
                specid = int(slice_data[0])
                offset = int(slice_data[1])
                seq = slice_data[3][:-1]
                if not is_on_plus_strand:
                    seq = reverse_complement(seq)             
                
                # convert characters to indices in the given alphabet
                seq_numbers = np.full(len(seq), None) # any unkown character is None and treated as missing data later
                
                for i in range(len(seq)):
                    if seq[i] in alpha_indices:
                        seq_numbers[i] = alpha_indices[seq[i]] # convert a to 0, c to 1, etc
                
                training_data[-1]["spec_ids"].append(specid)
                training_data[-1]["offsets"].append(offset)
                training_data[-1]["seq"].append(seq)
                training_data[-1]["S"].append(seq_numbers)
                
            # retrieve the number of species
            elif line[:8] == "species " and not skip_entry:
                specid = int(line[8:].split("\t")[0])
                num_species = max(num_species, specid + 1)
    # convert the sequences to numpy arrays
    for i in range(len(training_data)):
        training_data[i]["S"] = np.array(training_data[i]["S"])

    return training_data, num_species
